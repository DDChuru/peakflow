# Bank Statement Import to Ledger Posting - Complete Data Flow Analysis

## Executive Summary

This document provides a comprehensive map of how bank statements flow through the system from upload to final ledger posting. It identifies all Firestore collections, documents, services, and data dependencies to support safe data cleanup scripting.

---

## 1. BANK STATEMENT IMPORT FLOW

### 1.1 Bank Statement Upload & Storage

#### Upload Entry Point
- **UI Component**: `/src/components/bank-statement/BankStatementUpload`
- **Page**: `/app/workspace/[companyId]/bank-import/page.tsx`

#### Firebase Collection: `bank_statements`
A root-level collection storing raw bank statement PDFs and extracted data.

**Document ID**: Auto-generated by Firestore
**Data Structure**:
```firestore
bank_statements/{statementId}
├── companyId: string (reference to companies)
├── companyName?: string
├── uploadedAt: Timestamp
├── processedAt?: Timestamp
├── fileName: string
├── fileSize: number
├── status: 'pending' | 'processing' | 'completed' | 'failed'
├── accountInfo: {
│   ├── accountNumber: string
│   ├── accountName: string
│   ├── accountType?: string
│   ├── bankName: string
│   ├── branch?: string
│   ├── currency?: string
├── summary: {
│   ├── openingBalance: number
│   ├── closingBalance: number
│   ├── totalDeposits: number
│   ├── totalWithdrawals: number
│   ├── totalFees: number
│   ├── interestEarned: number
│   ├── transactionCount: number
│   └── statementPeriod: {
│       ├── from: string (ISO date)
│       └── to: string (ISO date)
├── transactions: BankTransaction[] (array of extracted transactions)
├── extractedData?: unknown (raw extraction data from Gemini)
├── error?: string
└── userId: string (who uploaded it)
```

**Key Type**: `BankTransaction[]` inside the document
```typescript
{
  id?: string
  date: string (ISO date or parsed format)
  description: string
  reference?: string
  debit?: number
  credit?: number
  balance: number
  type?: 'deposit' | 'withdrawal' | 'fee' | 'interest' | 'transfer' | 'other'
  category?: string
}
```

#### Processing Service
**File**: `/src/lib/firebase/bank-statement-service.ts`
- **Function**: `processBankStatement(pdfFile, companyId, companyName)`
- **Firebase Function Called**: `extractPDFContent` (Cloud Function)
- **Processing Steps**:
  1. Converts PDF to base64
  2. Calls Firebase Function to extract with Gemini
  3. Parses and normalizes transactions
  4. Bank-specific date parsing (e.g., FNB "DD MMM" format)
  5. Auto-fixes debit/credit amounts using bank parsers
  6. Validates and stores in Firestore
  7. Tracks usage in `usage_tracking` collection

**Related Files**:
- `/src/lib/banking/bank-parsers.ts` - Bank detection
- `/src/lib/banking/fix-statement-amounts.ts` - Amount correction

#### Usage Tracking
**Collection**: `usage_tracking`
```firestore
usage_tracking/{trackingId}
├── userId: string
├── companyId: string
├── function: 'processBankStatement'
├── fileName: string
├── timestamp: Timestamp
└── success: boolean
```

---

## 2. BANK-TO-LEDGER IMPORT SESSION

### 2.1 Import Session Creation & Transaction Mapping

#### Firebase Collection: `companies/{companyId}/bankImportSessions`

**Document ID**: Generated format `import_${timestamp}_${random}`
**Data Structure**:
```firestore
companies/{companyId}/bankImportSessions/{sessionId}
├── id: string
├── companyId: string
├── bankAccountId: string
├── bankAccountCode?: string
├── bankAccountName?: string
├── importDate: Timestamp
├── transactions: BankTransaction[] (from bank_statements)
├── status: 'pending' | 'processing' | 'completed' | 'failed'
├── createdBy: string (user ID)
├── createdAt: Timestamp (server timestamp)
├── updatedAt: Timestamp (server timestamp)
└── metadata?: {
    ├── fileName?: string
    ├── statementId?: string (reference to bank_statements/{statementId})
    ├── totalTransactions?: number
    └── processedTransactions?: number
}
```

**Creation Point**: `BankToLedgerService.createImportSession()`
**Location**: `/src/lib/accounting/bank-to-ledger-service.ts`

### 2.2 GL Mapping Rules Storage

#### Firebase Collection: `companies/{companyId}/glMappingRules`

Rules that automatically map bank transactions to GL accounts.

**Document ID**: Sanitized pattern name (e.g., `salary_payment`, `rent_expense`)
**Data Structure**:
```firestore
companies/{companyId}/glMappingRules/{ruleId}
├── id: string
├── companyId: string
├── pattern: string (e.g., "SALARY", "RENT PAYMENT")
├── patternType: 'contains' | 'starts_with' | 'ends_with' | 'regex'
├── glAccountCode: string (e.g., "5100" for Salaries)
├── glAccountId: string (reference to chart of accounts)
├── glAccountName?: string
├── matchField: 'description' | 'reference' | 'category' | 'amount'
├── transactionType?: 'debit' | 'credit' | 'both'
├── priority: number (lower = higher priority, evaluated first)
├── isActive: boolean
├── createdBy: string (user ID)
├── createdAt: Timestamp
├── updatedAt: Timestamp
├── usageCount?: number (times rule matched)
├── lastUsed?: Timestamp
└── metadata?: {
    ├── vendor?: string
    ├── category?: string
    ├── tags?: string[]
    ├── description?: string
    ├── source?: 'user-created' | 'ai-assisted'
    └── aiConfidence?: number
}
```

**Service Class**: `BankToLedgerService`
**Key Methods**:
- `saveMappingRule()` - Creates/updates rule
- `getMappingRules()` - Gets active rules (ordered by priority)
- `getAllMappingRules()` - Gets all rules including inactive
- `deleteMappingRule()` - Deletes a rule

**Related Service**: `RuleLearningService` (AI-assisted rule creation)
- **File**: `/src/lib/ai/rule-learning-service.ts`
- **Creates rules** when users approve AI-suggested mappings

---

## 3. TRANSACTION MAPPING & MATCHING

### 3.1 AI-Powered Mapping Pipeline

#### Mapping Pipeline
**File**: `/src/lib/ai/mapping-pipeline.ts`
**Class**: `MappingPipeline`

**Processing Stages**:
1. **Exact Match** - Looks for existing similar transactions
2. **Pattern Match** - Uses GL mapping rules to suggest accounts
3. **Fuzzy Match** - Levenshtein distance matching against vendor names
4. **Category Match** - Fall back to industry templates
5. **AI Suggestion** - Calls Claude to suggest mappings

**Output**: `ProcessingResult`
```typescript
{
  autoMapped: [
    {
      transaction: BankTransaction,
      mapping: TransactionMapping
    }
  ],
  needsReview: [
    {
      transaction: BankTransaction,
      suggestedMapping: TransactionMapping
    }
  ],
  needsAI: [{ transaction: BankTransaction }],
  stats: {
    total: number,
    autoMappedCount: number,
    autoMappedPercentage: number,
    needsReviewCount: number,
    needsAICount: number,
    estimatedAICost: number,
    processingTimeMs: number
  }
}
```

### 3.2 UI Component for Mapping

**Component**: `/src/components/banking/BankToLedgerImport.tsx`

**State Management**:
- `transactions`: Loaded from bank statement
- `mappings`: Map<transactionId, GLMapping>
- `selectedTransactions`: Set of transaction IDs to post
- `currentStep`: 'select' | 'mapping' | 'preview' | 'posting' | 'complete'

**GL Mapping Structure**:
```typescript
interface GLMapping {
  debitAccount?: {
    id: string,
    code: string,
    name: string
  },
  creditAccount?: {
    id: string,
    code: string,
    name: string
  },
  confidence?: number,
  ruleApplied?: string,
  manuallyMapped?: boolean
}
```

---

## 4. JOURNAL ENTRY CREATION & LEDGER POSTING

### 4.1 Journal Entry Creation

**Service Class**: `BankToLedgerService`
**Method**: `createJournalEntry(mapping, fiscalPeriodId, createdBy)`
**Location**: `/src/lib/accounting/bank-to-ledger-service.ts` (line 453)

**Generated Journal Entry**:
```typescript
{
  id: string (format: `bank_${bankTransaction.id}_${Date.now()}`),
  tenantId: string (companyId),
  fiscalPeriodId: string,
  journalCode: 'BANK_IMPORT',
  reference: string (e.g., 'BANK-${bankTransactionId}'),
  description: `Bank import: ${bankTransaction.description}`,
  status: 'draft',
  source: 'bank_import',
  transactionDate: Date (from bank transaction),
  postingDate: Date (current date),
  createdBy: string (user ID),
  metadata?: {
    bankTransactionId: string,
    bankTransactionDate: string,
    originalDescription: string,
    ...mappingMetadata
  },
  lines: JournalLine[],
  createdAt: Date,
  updatedAt: Date
}
```

**Journal Lines** (always 2 lines - debit and credit):
```typescript
{
  id: string (e.g., `${bankTransactionId}_debit`),
  accountId: string,
  accountCode: string,
  accountName: string,
  description?: string,
  debit: number,
  credit: number (0 for debit line, amount for credit line),
  currency: string,
  dimensions?: Record<string, string>
}
```

### 4.2 Posting to General Ledger

#### Firebase Collection: `journal_entries`

**Document ID**: Auto-generated or specified (format: `bank_${txId}_${timestamp}`)
**Data Structure**:
```firestore
journal_entries/{journalEntryId}
├── id: string
├── tenantId: string (companyId)
├── fiscalPeriodId: string (reference to fiscal_periods)
├── journalCode: string ('BANK_IMPORT')
├── reference: string
├── description: string
├── status: 'draft' | 'posted' | 'voided'
├── source: 'bank_import'
├── transactionDate: Timestamp
├── postingDate: Timestamp
├── createdBy: string
├── approvedBy?: string
├── reversalOf?: string
├── metadata: {
│   ├── bankTransactionId: string
│   ├── bankTransactionDate: string
│   ├── originalDescription: string
│   └── ...customMetadata
├── lines: JournalLine[]
├── createdAt: Timestamp
└── updatedAt: Timestamp
```

#### Firebase Collection: `general_ledger`

When posting, each journal line creates a ledger entry.

**Document ID**: Auto-generated
**Data Structure**:
```firestore
general_ledger/{ledgerEntryId}
├── id: string
├── tenantId: string (companyId)
├── journalEntryId: string (reference back to journal_entries)
├── journalLineId: string (e.g., `${bankTransactionId}_debit`)
├── accountId: string
├── accountCode: string
├── accountName: string
├── description?: string
├── debit: number
├── credit: number
├── cumulativeBalance: number (calculated field)
├── currency: string
├── transactionDate: Timestamp
├── postingDate: Timestamp
├── fiscalPeriodId: string
├── source: 'bank_import'
├── metadata?: {
│   ├── bankTransactionId: string
│   ├── originalDescription: string
│   └── ...customMetadata
├── dimensions?: {
│   ├── customerId?: string
│   ├── supplierId?: string
│   └── ...other dimensions
└── createdAt: Timestamp
```

### 4.3 Posting Service

**File**: `/src/lib/accounting/posting-service.ts`
**Class**: `PostingService`
**Key Methods**:
- `validate(entry)` - Validates journal entry is balanced
- `post(entry)` - Posts to general_ledger (within transaction)

**Posting Flow**:
1. Validates entry is balanced (total debit == total credit)
2. Checks fiscal period is open
3. Creates ledger entries for each journal line
4. Updates journal entry status to 'posted'
5. All done atomically within a Firestore transaction

---

## 5. SUPPORTING DATA STRUCTURES

### 5.1 Chart of Accounts (GL Accounts)

**Service**: `IndustryTemplateService`
**Location**: `/src/lib/accounting/industry-template-service.ts`

**Collections**:
```firestore
companies/{companyId}/accountTemplate/{templateId}
  └── Contains account data for company

industry-templates/{templateId}/accounts/{accountId}
  └── Shared industry templates
```

**Account Record Structure**:
```typescript
{
  id: string,
  code: string (e.g., "1100", "5000"),
  name: string,
  category?: string,
  subCategory?: string,
  type: 'asset' | 'liability' | 'equity' | 'revenue' | 'expense',
  balance?: number,
  currency?: string
}
```

### 5.2 Fiscal Periods

**Collection**: `fiscal_periods` (root level)
**Status**: 'open' | 'closed'

Required for posting - transactions must be posted to an open fiscal period.

**Document Structure**:
```firestore
fiscal_periods/{periodId}
├── id: string
├── companyId: string
├── name: string (e.g., "2024 Q1")
├── startDate: Timestamp
├── endDate: Timestamp
├── status: 'open' | 'closed'
├── createdAt: Timestamp
└── updatedAt: Timestamp
```

### 5.3 Bank Accounts

**Collection**: `companies/{companyId}/bankAccounts`
**Service**: `bankAccountService`

Bank account metadata linked to import sessions.

---

## 6. COMPLETE DATA DEPENDENCY GRAPH

```
UPLOAD
  ↓
bank_statements/{statementId}
  ├─ Contains transactions[]
  └─ References companyId
  
  ↓
BankToLedgerImport Component (UI)
  ├─ Loads bank statement
  ├─ Loads GL accounts from chart
  ├─ Applies mapping pipeline
  └─ Shows mapping suggestions
  
  ↓
companies/{companyId}/bankImportSessions/{sessionId}
  ├─ Stores transaction array
  ├─ Stores session metadata
  └─ Tracks processing status
  
  ↓
companies/{companyId}/glMappingRules/{ruleId}
  ├─ Used during mapping pipeline
  ├─ Created/updated via RuleLearningService
  └─ Referenced for pattern matching
  
  ↓
User Reviews Mappings
  ├─ Manual mapping via UI
  └─ AI-assisted mapping via Claude
  
  ↓
BankToLedgerService.postToLedger()
  ├─ Creates journal entry
  ├─ Creates journal line for each mapping
  └─ Creates ledger entry for each line
  
  ↓
journal_entries/{journalEntryId}
  ├─ Status: 'draft' → 'posted'
  ├─ Contains lines[]
  ├─ References fiscalPeriodId
  └─ Metadata includes bankTransactionId
  
  ↓
general_ledger/{ledgerEntryId}
  ├─ One per journal line (typically 2: debit + credit)
  ├─ References journalEntryId
  ├─ References accountId
  └─ Affects account balance
```

---

## 7. RECONCILIATION INTEGRATION

### 7.1 Reconciliation Sessions

**Collection**: `companies/{companyId}/reconciliations/{sessionId}`

After posting bank transactions, they can be reconciled with bank statements.

**Matches Collection**: `companies/{companyId}/reconciliations/{sessionId}/matches/{matchId}`
- Links ledger entries to bank transactions
- Tracks matching status

**Adjustments Collection**: `companies/{companyId}/reconciliations/{sessionId}/adjustments/{adjustmentId}`
- Creates adjustment journal entries for discrepancies

---

## 8. DATA CLEANUP DEPENDENCY MAP FOR DELETION

### Safe Deletion Order (Top-Down)

1. **Delete Bank Statement**:
   - `bank_statements/{statementId}`
   - `usage_tracking` entries (optional, for audit trail)

2. **Delete Bank Import Session**:
   - `companies/{companyId}/bankImportSessions/{sessionId}`

3. **Delete Mapping Rules** (if created for this import):
   - `companies/{companyId}/glMappingRules/{ruleId}`

4. **Delete Journal Entry** (CRITICAL - DELETE BEFORE LEDGER):
   - `journal_entries/{journalEntryId}`
   - STATUS: Must be 'draft' or voided before deletion

5. **Delete General Ledger Entries**:
   - `general_ledger/{ledgerEntryId}` entries with matching journalEntryId
   - STATUS: Only if associated journal entry is deleted

6. **Delete Reconciliation Data** (if any):
   - `companies/{companyId}/reconciliations/{sessionId}/matches/{matchId}`
   - `companies/{companyId}/reconciliations/{sessionId}/adjustments/{adjustmentId}`

### Critical Constraints

- **Cannot Delete Posted Entries**: Journal entries with status='posted' should be voided first
- **Foreign Key Constraints**:
  - `general_ledger.journalEntryId` must reference existing `journal_entries`
  - `journal_entries.fiscalPeriodId` must reference existing `fiscal_periods`
  - `glMappingRules.glAccountId` must reference existing GL account
- **Cascade Considerations**:
  - Deleting journal entry does NOT cascade to ledger entries (must delete separately)
  - Deleting bank statement does NOT delete sessions (must delete separately)

---

## 9. KEY FILES AND SERVICES

### Service Files
- `/src/lib/firebase/bank-statement-service.ts` - Upload & processing
- `/src/lib/accounting/bank-to-ledger-service.ts` - Session & posting
- `/src/lib/accounting/posting-service.ts` - Ledger posting
- `/src/lib/accounting/journal-service.ts` - Journal queries
- `/src/lib/ai/mapping-pipeline.ts` - Transaction mapping
- `/src/lib/ai/rule-learning-service.ts` - Rule creation
- `/src/lib/accounting/reconciliation-service.ts` - Reconciliation

### Type Definitions
- `/src/types/bank-statement.ts` - BankStatement, BankTransaction
- `/src/types/accounting/bank-import.ts` - ImportedTransaction, GLMapping
- `/src/types/accounting/journal.ts` - JournalEntry, JournalLine
- `/src/types/accounting/general-ledger.ts` - LedgerEntry

### Components
- `/src/components/banking/BankToLedgerImport.tsx` - Main UI
- `/src/components/bank-statement/BankStatementUpload.tsx` - Upload UI

### Firebase Functions
- `extractPDFContent` - PDF parsing & extraction (Cloud Function)

---

## 10. FIRESTORE SECURITY RULES IMPLICATIONS

From `firestore.rules`:
- Bank import data is company-scoped
- Journal entries and ledger entries require tenantId validation
- Only authenticated users can access their company data

---

## 11. AUDIT TRAIL & USAGE TRACKING

### Collections to Preserve for Audit
- `usage_tracking` - Track of all function calls
- `activities` - General activity log
- `journal_entries` metadata - Contains who created, when, source

### Collections Safe to Cleanup
- `bank_statements` (orphaned, no references)
- `bankImportSessions` (if no active processing)
- `general_ledger` entries (after voiding corresponding journal)

---

## Recommended Data Cleanup Script Flow

```typescript
interface CleanupOptions {
  companyId: string;
  statementId?: string;  // Clean single statement
  sessionId?: string;    // Clean specific session
  dryRun?: boolean;      // Preview what would be deleted
  force?: boolean;       // Force delete even if posted
}

async function cleanupBankImport(options: CleanupOptions) {
  // 1. Find all affected documents
  const statement = await getBankStatement(options.statementId);
  const sessions = await findSessionsByStatement(statement.id);
  const journalEntries = await findJournalsBySession(sessions);
  const ledgerEntries = await findLedgerByJournals(journalEntries);
  const rules = await findRulesByCompany(options.companyId);
  const reconciliation = await findReconciliationMatches(journalEntries);
  
  // 2. Validate deletability
  validateCanDelete(journalEntries, options.force);
  
  // 3. Report impact
  reportDeletionImpact({
    statement: 1,
    sessions: sessions.length,
    journalEntries: journalEntries.length,
    ledgerEntries: ledgerEntries.length,
    rules: rules.length,
    reconciliationMatches: reconciliation.length
  });
  
  if (options.dryRun) return;
  
  // 4. Execute deletion in order
  await deleteInOrder([
    { collection: 'bank_statements', ids: [statement.id] },
    { collection: 'bankImportSessions', ids: sessions.map(s => s.id) },
    { collection: 'glMappingRules', ids: rules.map(r => r.id) },
    { collection: 'reconciliationMatches', ids: reconciliation.map(r => r.id) },
    { collection: 'journal_entries', ids: journalEntries.map(j => j.id) },
    { collection: 'general_ledger', ids: ledgerEntries.map(l => l.id) }
  ]);
}
```

